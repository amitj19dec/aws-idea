<repo-to-text>
Directory: terraform

Directory Structure:
<directory_structure>
.
.
├── ./base
│   ├── ./base/data.tf
│   ├── ./base/endpoints
│   │   ├── ./base/endpoints/data.tf
│   │   ├── ./base/endpoints/main.tf
│   │   └── ./base/endpoints/variables.tf
│   ├── ./base/inputs
│   │   └── ./base/inputs/sandbox
│   │       └── ./base/inputs/sandbox/982534393096_46de60f5-2b31-4fb7-9cbf-b728d5b104e3.tfvars
│   ├── ./base/locals.tf
│   ├── ./base/main.tf
│   ├── ./base/outputs.tf
│   ├── ./base/param_store_values.tf
│   ├── ./base/policies
│   │   ├── ./base/policies/bedrock_kb
│   │   │   └── ./base/policies/bedrock_kb/bedrock_kb_custom.tpl
│   │   ├── ./base/policies/glue
│   │   │   └── ./base/policies/glue/glue.tpl
│   │   ├── ./base/policies/lambda
│   │   │   ├── ./base/policies/lambda/ai.json.tpl
│   │   │   ├── ./base/policies/lambda/base.json.tpl
│   │   │   ├── ./base/policies/lambda/data.json.tpl
│   │   │   ├── ./base/policies/lambda/monitoring.json.tpl
│   │   │   └── ./base/policies/lambda/secret.json.tpl
│   │   ├── ./base/policies/lex
│   │   │   └── ./base/policies/lex/lex.tpl
│   │   ├── ./base/policies/opensearch
│   │   │   └── ./base/policies/opensearch/opensearch_master.tpl
│   │   └── ./base/policies/sagemaker
│   │       └── ./base/policies/sagemaker/sagemaker_custom.tpl
│   ├── ./base/provider.tf
│   ├── ./base/role_bedrock_kb.tf
│   ├── ./base/role_opensearch.tf
│   ├── ./base/role_sagemaker.tf
│   ├── ./base/roles_glue.tf
│   ├── ./base/roles_lambda.tf
│   ├── ./base/roles_lex.tf
│   ├── ./base/s3_bucket
│   │   ├── ./base/s3_bucket/byod_bucket.tf
│   │   ├── ./base/s3_bucket/data.tf
│   │   ├── ./base/s3_bucket/outputs.tf
│   │   ├── ./base/s3_bucket/service_bucket.tf
│   │   ├── ./base/s3_bucket/variables.tf
│   │   └── ./base/s3_bucket/workspace_bucket.tf
│   └── ./base/variables.tf
├── ./bedrock-kb
│   ├── ./bedrock-kb/data.tf
│   ├── ./bedrock-kb/inputs
│   │   └── ./bedrock-kb/inputs/sandbox
│   │       └── ./bedrock-kb/inputs/sandbox/982534393096_46de60f5-2b31-4fb7-9cbf-b728d5b104e3.tfvars
│   ├── ./bedrock-kb/locals.tf
│   ├── ./bedrock-kb/main.tf
│   ├── ./bedrock-kb/outputs.tf
│   ├── ./bedrock-kb/param_store_values.tf
│   ├── ./bedrock-kb/provider.tf
│   └── ./bedrock-kb/variables.tf
├── ./glue
│   ├── ./glue/locals.tf
│   ├── ./glue/main.tf
│   ├── ./glue/provider.tf
│   └── ./glue/variables.tf
├── ./lambda
│   ├── ./lambda/data.tf
│   ├── ./lambda/inputs
│   │   └── ./lambda/inputs/lambda-invoke-endpoint.tfvars
│   ├── ./lambda/lambda_function.zip
│   ├── ./lambda/lambda-function
│   │   └── ./lambda/lambda-function/lambda_function.py
│   ├── ./lambda/main.tf
│   ├── ./lambda/outputs.tf
│   ├── ./lambda/provider.tf
│   └── ./lambda/variables.tf
├── ./managed-opensearch
│   ├── ./managed-opensearch/data.tf
│   ├── ./managed-opensearch/inputs
│   │   └── ./managed-opensearch/inputs/982534393096_46de60f5-2b31-4fb7-9cbf-b728d5b104e3.tfvars
│   ├── ./managed-opensearch/locals.tf
│   ├── ./managed-opensearch/main.tf
│   ├── ./managed-opensearch/outputs.tf
│   └── ./managed-opensearch/variables.tf
└── ./sagemaker-infra
    ├── ./sagemaker-infra/data.tf
    ├── ./sagemaker-infra/inputs
    │   └── ./sagemaker-infra/inputs/sandbox
    │       └── ./sagemaker-infra/inputs/sandbox/982534393096_46de60f5-2b31-4fb7-9cbf-b728d5b104e3.tfvars
    ├── ./sagemaker-infra/locals.tf
    ├── ./sagemaker-infra/main.tf
    ├── ./sagemaker-infra/outputs.tf
    ├── ./sagemaker-infra/param_store_values.tf
    ├── ./sagemaker-infra/provider.tf
    └── ./sagemaker-infra/variables.tf

</directory_structure>

<content full_path="glue/locals.tf">
locals {
  base_prefix   = "uais-${split("-", var.project_id)[0]}"
  glue_catalog  = format("${local.base_prefix}-glue-catalog")
}

</content>

<content full_path="glue/main.tf">
resource "aws_glue_catalog_database" "aws" {
  name = local.glue_catalog
  description = "The Glue Catalog database"
}
</content>

<content full_path="glue/variables.tf">
variable "aws_region" {
  description = "AWS Region."
  type        = string
  default     = "us-east-1"
}

variable "project_id" {
  description = "UAIS Project ID tied to the workspace"
  type        = string
}

# variable "glue_catalog_name" {
#   description = "The name of the Glue Catalog database"
#   type        = string
# }
</content>

<content full_path="glue/provider.tf">
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
  #   backend "s3" {
  #     access_key = ""
  #     secret_key = ""
  #     token      = ""
  #     bucket     = ""
  #     key        = ""
  #     region     = ""
  #   }
}

provider "aws" {

  #   access_key = var.aws_access_key
  #   secret_key = var.aws_secret_key
  region = var.aws_region
  #
  #   assume_role {
  #     role_arn = "arn:aws:iam::${var.aws_account_id}:role/uais_admin_access_role"
  #   }
}
</content>

<content full_path="sagemaker-infra/data.tf">
data "aws_caller_identity" "current" {}

data "aws_region" "current" {}

data "aws_vpc" "spoke_vpc" {
  filter {
    name   = "tag:Name"
    values = ["${local.base_prefix}-vpc"]
  }
}

data "aws_kms_key" "base_kms_key" {
  key_id = local.kms_key_alias
}

data "aws_subnets" "sagemaker_subnets" {
  filter {
    name   = "vpc-id"
    values = [data.aws_vpc.spoke_vpc.id]
  }

  filter {
    name   = "tag:Name"
    values = ["${local.base_prefix}-sagemaker*"]
  }
}

data "aws_s3_bucket" "workspace_bucket" {
  bucket = "${local.base_prefix}-workspace-bucket"
}

data "aws_s3_bucket" "byod_bucket" {
  bucket = "${local.base_prefix}-byod-bucket"
}

data "aws_ecr_repository" "base_ecr" {
  name = "${local.base_prefix}-ecr"
}

data "aws_iam_role" "sagemaker_domain_default_execution_role" {
  name = local.sagemaker_role_name
}

data "aws_security_group" "sagemaker_sg" {
  name   = "${local.base_prefix}-sagemaker-sg"
  vpc_id = data.aws_vpc.spoke_vpc.id
}

</content>

<content full_path="sagemaker-infra/outputs.tf">
output "sagemaker_domain_id" {
  value       = aws_sagemaker_domain.sagemaker_domain.id
  description = "The ID of the created SageMaker domain"
}
</content>

<content full_path="sagemaker-infra/locals.tf">
locals {
  optum_ip_whitelist = ["168.183.0.0/16", "149.111.0.0/16", "128.35.0.0/16", "161.249.0.0/16", "198.203.174.0/23",
  "198.203.176.0/22", "198.203.180.0/23"]
  resource_provisioner = "UAIS"
  base_prefix          = "uais-${split("-", var.project_id)[0]}"
  kms_key_alias        = "alias/${local.base_prefix}-kms-key"
  sagemaker_role_name  = "${local.base_prefix}-sagemaker-domain-exec-role"
}
</content>

<content full_path="sagemaker-infra/main.tf">
resource "aws_sagemaker_domain" "sagemaker_domain" {
  domain_name             = "${local.base_prefix}-sagemaker-domain"
  app_network_access_type = var.app_network_access_type
  auth_mode               = var.auth_mode
  vpc_id                  = data.aws_vpc.spoke_vpc.id
  subnet_ids              = data.aws_subnets.sagemaker_subnets.ids
  kms_key_id              = data.aws_kms_key.base_kms_key.arn

  default_space_settings {
    execution_role = data.aws_iam_role.sagemaker_domain_default_execution_role.arn
  }

  default_user_settings {
    execution_role    = data.aws_iam_role.sagemaker_domain_default_execution_role.arn
    studio_web_portal = "ENABLED"
    sharing_settings {
      notebook_output_option = "Allowed"
      s3_kms_key_id          = data.aws_kms_key.base_kms_key.arn
      s3_output_path         = "s3://${data.aws_s3_bucket.workspace_bucket.id}/shared-notebooks"
    }
  }

  domain_settings {
    security_group_ids = [data.aws_security_group.sagemaker_sg.id]
  }

  retention_policy {
    home_efs_file_system = "Retain"
  }

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
      name       = "${local.base_prefix}-sagemaker-domain"
    }
  )
}

resource "aws_sagemaker_user_profile" "default_user" {
  for_each = toset(var.user_profile_names)

  domain_id         = aws_sagemaker_domain.sagemaker_domain.id
  user_profile_name = each.value

  user_settings {
    execution_role  = data.aws_iam_role.sagemaker_domain_default_execution_role.arn
    security_groups = [data.aws_security_group.sagemaker_sg.id]
  }

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
      username   = each.value
    }
  )
}
</content>

<content full_path="sagemaker-infra/param_store_values.tf">
resource "aws_ssm_parameter" "sagemaker_domain_id" {
  name  = "/params/${local.base_prefix}/platform/sagemaker-domain-id"
  type  = "String"
  value = aws_sagemaker_domain.sagemaker_domain.id

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
    }
  )
}

resource "aws_ssm_parameter" "sagemaker_domain_arn" {
  name  = "/params/${local.base_prefix}/platform/sagemaker-domain-arn"
  type  = "String"
  value = aws_sagemaker_domain.sagemaker_domain.arn

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
    }
  )
}
</content>

<content full_path="sagemaker-infra/variables.tf">
variable "aws_region" {
  description = "AWS Region."
  type        = string
  default     = "us-east-1"
}

variable "project_id" {
  description = "UAIS Project ID tied to the workspace"
  type        = string
}

variable "tags" {
  type        = map(string)
  description = "Tags to apply to resources."
}

variable "aws_account_id" {
  description = "AWS Account ID"
  type        = string
}

variable "auth_mode" {
  description = "The mode of authentication that members use to access the domain. Valid values are IAM and SSO"
  type        = string
  default     = "IAM"
}

variable "app_network_access_type" {
  description = "The network access type for the App domain. Valid values are PublicInternetOnly and VpcOnly"
  type        = string
  default     = "VpcOnly"
}

variable "user_profile_names" {
  type    = list(string)
  default = ["defaultuser"] # Replace with your actual list of user profile names
}

variable "enable_bedrock_access" {
  description = "Enable Bedrock access for the Sagemaker domain"
  type        = bool
  default     = false
}
</content>

<content full_path="sagemaker-infra/provider.tf">
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
#   backend "s3" {
#     access_key = ""
#     secret_key = ""
#     token      = ""
#     bucket     = ""
#     key        = ""
#     region     = ""
#   }
}

provider "aws" {

  #   access_key = var.aws_access_key
  #   secret_key = var.aws_secret_key
  region = var.aws_region
  #
  #   assume_role {
  #     role_arn = "arn:aws:iam::${var.aws_account_id}:role/uais_admin_access_role"
  #   }
}
</content>

<content full_path="sagemaker-infra/inputs/sandbox/982534393096_46de60f5-2b31-4fb7-9cbf-b728d5b104e3.tfvars">
aws_region     = "us-east-1"
aws_account_id = "982534393096"
project_id     = "46de60f5-2b31-4fb7-9cbf-b728d5b104e3"

tags = {
  "project_id"   = "46de60f5-2b31-4fb7-9cbf-b728d5b104e3",
  "aide-id"      = "AIDE_0074310"
  "hcp_rg"       = "migration-aide-0074310-4416a57",
  "environment"  = "dev",
  "service-tier" = "p2"
}

enable_bedrock_access = true
</content>

<content full_path="managed-opensearch/data.tf">
data "aws_caller_identity" "current" {}

data "aws_region" "current" {}

data "aws_vpc" "spoke_vpc" {
  filter {
    name   = "tag:Name"
    values = ["${local.base_prefix}-vpc"]
  }
}

data "aws_kms_key" "base_kms_key" {
  key_id = local.kms_key_alias
}

data "aws_subnets" "opensearch_subnets" {
  filter {
    name   = "vpc-id"
    values = [data.aws_vpc.spoke_vpc.id]
  }

  filter {
    name   = "tag:Name"
    values = ["${local.base_prefix}-endpoints*"]
  }
}

data "aws_iam_role" "opensearch_master_role" {
  name = "${local.base_prefix}-opensearch-master-role"
}

#data "aws_iam_role" "lambda_exec_role" {
#  name = "${local.base_prefix}-lambda-exec-role"
#}

data "aws_iam_role" "sagemaker_domain_exec_role" {
  name = "${local.base_prefix}-sagemaker-domain-exec-role"
}

# Fetch the OpenSearch security group created in the base module
data "aws_security_group" "opensearch_sg" {
  filter {
    name   = "tag:name"
    values = ["${local.base_prefix}-opensearch-sg"]
  }
  filter {
    name   = "vpc-id"
    values = [data.aws_vpc.spoke_vpc.id]
  }
}

</content>

<content full_path="managed-opensearch/outputs.tf">
output "opensearch_domain_id" {
  value       = aws_opensearch_domain.opensearch.id
  description = "The ID of the OpenSearch domain"
}

output "opensearch_domain_arn" {
  value       = aws_opensearch_domain.opensearch.arn
  description = "The ARN of the OpenSearch domain"
}

output "opensearch_endpoint" {
  value       = aws_opensearch_domain.opensearch.endpoint
  description = "The OpenSearch domain endpoint"
}

output "opensearch_domain_name" {
  value       = aws_opensearch_domain.opensearch.domain_name
  description = "The name of the OpenSearch domain"
}

output "opensearch_security_group_id" {
  value       = data.aws_security_group.opensearch_sg.id
  description = "The ID of the OpenSearch security group"
}

</content>

<content full_path="managed-opensearch/locals.tf">
locals {
  optum_ip_whitelist = ["168.183.0.0/16", "149.111.0.0/16", "128.35.0.0/16", "161.249.0.0/16", "198.203.174.0/23",
  "198.203.176.0/22", "198.203.180.0/23"]
  resource_provisioner = "UAIS"
  base_prefix          = "uais-${split("-", var.project_id)[0]}"
  kms_key_alias        = "alias/${local.base_prefix}-kms-key"
  opensearch_master_role_name = "${local.base_prefix}-opensearch-master-role"
}
</content>

<content full_path="managed-opensearch/main.tf">
resource "aws_opensearch_domain" "opensearch" {
  domain_name    = "${local.base_prefix}-opensearch"
  engine_version = var.engine_version

  cluster_config {
    instance_type            = var.instance_type
    instance_count           = var.instance_count
    dedicated_master_enabled = var.dedicated_master_enabled
    dedicated_master_type     = var.dedicated_master_type
    dedicated_master_count    = var.dedicated_master_count
    zone_awareness_enabled   = var.zone_awareness_enabled

    dynamic "zone_awareness_config" {
      for_each = var.zone_awareness_enabled ? [1] : []
      content {
        availability_zone_count = length(data.aws_subnets.opensearch_subnets.ids)
      }
    }
  }

  # VPC configuration for private deployment
  vpc_options {
    subnet_ids         = data.aws_subnets.opensearch_subnets.ids
    security_group_ids = [data.aws_security_group.opensearch_sg.id]
  }

  # EBS storage configuration
  ebs_options {
    ebs_enabled = true
    volume_type = var.ebs_volume_type
    volume_size = var.ebs_volume_size
  }

  # Fine-grained access control with IAM master user
  advanced_security_options {
    enabled                        = true
    anonymous_auth_enabled         = false
    internal_user_database_enabled = false
    master_user_options {
      master_user_arn = data.aws_iam_role.opensearch_master_role.arn
    }
  }

  # Encryption at rest using project-scoped KMS key
  encrypt_at_rest {
    enabled    = true
    kms_key_id = data.aws_kms_key.base_kms_key.arn
  }

  # Node-to-node encryption
  node_to_node_encryption {
    enabled = true
  }

  # Domain endpoint options
  domain_endpoint_options {
    enforce_https       = true
    tls_security_policy = "Policy-Min-TLS-1-2-2019-07"
  }

  # Log publishing configuration
  log_publishing_options {
    enabled                  = true
    log_type                 = "SEARCH_SLOW_LOGS"
    cloudwatch_log_group_arn = aws_cloudwatch_log_group.opensearch_slow_logs.arn
  }

  log_publishing_options {
    enabled                  = true
    log_type                 = "ES_APPLICATION_LOGS"
    cloudwatch_log_group_arn = aws_cloudwatch_log_group.opensearch_app_logs.arn
  }

  log_publishing_options {
    enabled                  = true
    log_type                 = "AUDIT_LOGS"
    cloudwatch_log_group_arn = aws_cloudwatch_log_group.opensearch_audit_logs.arn
  }

  # Access policy restricting to project VPC
  access_policies = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          AWS = [
            data.aws_iam_role.opensearch_master_role.arn,
            #data.aws_iam_role.lambda_exec_role.arn,
            data.aws_iam_role.sagemaker_domain_exec_role.arn
          ]
        }
        Action   = "es:*"
        Resource = "arn:aws:es:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:domain/${local.base_prefix}-opensearch/*"
      }
    ]
  })

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
      name       = "${local.base_prefix}-opensearch"
    }
  )

  depends_on = [
    aws_cloudwatch_log_group.opensearch_slow_logs,
    aws_cloudwatch_log_group.opensearch_app_logs,
    aws_cloudwatch_log_group.opensearch_audit_logs,
    aws_cloudwatch_log_resource_policy.opensearch_logs_policy
  ]
}

# CloudWatch log groups for OpenSearch logs
resource "aws_cloudwatch_log_group" "opensearch_slow_logs" {
  name              = "/aws/opensearch/domains/${local.base_prefix}-opensearch/search-slow-logs"
  retention_in_days = 30
  # kms_key_id        = data.aws_kms_key.base_kms_key.arn

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
    }
  )
}

resource "aws_cloudwatch_log_group" "opensearch_app_logs" {
  name              = "/aws/opensearch/domains/${local.base_prefix}-opensearch/application-logs"
  retention_in_days = 30
  # kms_key_id        = data.aws_kms_key.base_kms_key.arn

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
    }
  )
}

resource "aws_cloudwatch_log_group" "opensearch_audit_logs" {
  name              = "/aws/opensearch/domains/${local.base_prefix}-opensearch/audit-logs"
  retention_in_days = 90
  # kms_key_id        = data.aws_kms_key.base_kms_key.arn

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
    }
  )
}

# CloudWatch log resource policy to allow OpenSearch to write logs
resource "aws_cloudwatch_log_resource_policy" "opensearch_logs_policy" {
  policy_name = "${local.base_prefix}-opensearch-logs-policy"
  policy_document = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          Service = "es.amazonaws.com"
        }
        Action = [
          "logs:PutLogEvents",
          "logs:CreateLogStream"
        ]
        Resource = [
          "${aws_cloudwatch_log_group.opensearch_slow_logs.arn}:*",
          "${aws_cloudwatch_log_group.opensearch_app_logs.arn}:*",
          "${aws_cloudwatch_log_group.opensearch_audit_logs.arn}:*"
        ]
      }
    ]
  })
}

# Parameter Store for service discovery
resource "aws_ssm_parameter" "opensearch_endpoint" {
  name  = "/params/${local.base_prefix}/platform/opensearch-endpoint"
  type  = "String"
  value = aws_opensearch_domain.opensearch.endpoint

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
    }
  )
}

resource "aws_ssm_parameter" "opensearch_domain_arn" {
  name  = "/params/${local.base_prefix}/platform/opensearch-domain-arn"
  type  = "String"
  value = aws_opensearch_domain.opensearch.arn

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
    }
  )
}

</content>

<content full_path="managed-opensearch/variables.tf">
variable "aws_region" {
  description = "AWS Region."
  type        = string
  default     = "us-east-1"
}

variable "project_id" {
  description = "UAIS Project ID tied to the workspace"
  type        = string
}

variable "tags" {
  type        = map(string)
  description = "Tags to apply to resources."
}

variable "aws_account_id" {
  description = "AWS Account ID"
  type        = string
}

variable "instance_type" {
  description = "Instance type for OpenSearch data nodes"
  type        = string
  default     = "m6g.large.search"
}

variable "instance_count" {
  description = "Number of data nodes in the OpenSearch domain"
  type        = number
  default     = 2
}

variable "dedicated_master_enabled" {
  description = "Enable dedicated master nodes"
  type        = bool
  default     = true
}

variable "dedicated_master_type" {
  description = "Instance type for OpenSearch master nodes"
  type        = string
  default     = "m6g.large.search"
}

variable "dedicated_master_count" {
  description = "Number of dedicated master nodes"
  type        = number
  default     = 3
}

variable "ebs_volume_size" {
  description = "EBS volume size for OpenSearch nodes (GB)"
  type        = number
  default     = 100
}

variable "ebs_volume_type" {
  description = "EBS volume type for OpenSearch nodes"
  type        = string
  default     = "gp3"
}

variable "engine_version" {
  description = "OpenSearch engine version"
  type        = string
  default     = "OpenSearch_2.13"
}

variable "zone_awareness_enabled" {
  description = "Enable zone awareness for multi-AZ deployment"
  type        = bool
  default     = true
}
</content>

<content full_path="managed-opensearch/inputs/982534393096_46de60f5-2b31-4fb7-9cbf-b728d5b104e3.tfvars">
aws_region     = "us-east-1"
aws_account_id = "982534393096"
project_id     = "46de60f5-2b31-4fb7-9cbf-b728d5b104e3"


vpc = {
  cidr_block             = "10.93.128.0/22"
  number_azs             = 2
  sagemaker_subnet_cidrs = ["10.93.128.0/25", "10.93.128.128/25"]
  endpoint_subnet_cidrs  = ["10.93.129.0/25", "10.93.129.128/25"]
}

tags = {
  "project_id"   = "46de60f5-2b31-4fb7-9cbf-b728d5b104e3",
  "aide-id"      = "AIDE_0074310"
  "hcp_rg"       = "migration-aide-0074310-4416a57",
  "environment"  = "dev",
  "service-tier" = "p2"
}

endpoint_names = ["ecr.api", "ecr.dkr", "logs", "ssm", "ssmmessages", "ec2messages", "sagemaker.api", "secretsmanager", "sagemaker.runtime",
  "sagemaker.featurestore-runtime", "servicecatalog", "forecast", "forecastquery", "rekognition", "textract", "comprehend", "sts", "redshift-data",
"athena", "glue", "codewhisperer"]

</content>

<content full_path="bedrock-kb/data.tf">
data "aws_caller_identity" "current" {}

data "aws_region" "current" {}

# the workspace bucket is used to store the raw data files
# customer can bring data in byod bucket and apply transformations and then move transformed dat to workspace bucket
data "aws_s3_bucket" "raw_data_bucket" {
  bucket = local.raw_data_bucket_name
}

data "aws_iam_role" "bedrock_kb_role" {
  name = local.bedrock_kb_role_name
}

data "aws_kms_key" "base_kms_key" {
  key_id = local.kms_key_alias
}

data "aws_vpc" "spoke_vpc" {
  filter {
    name   = "tag:Name"
    values = ["${local.base_prefix}-vpc"]
  }
}

data "aws_subnets" "endpoints_subnets" {
  filter {
    name   = "vpc-id"
    values = [data.aws_vpc.spoke_vpc.id]
  }

  filter {
    name   = "tag:Name"
    values = ["${local.base_prefix}-endpoints*"]
  }
}

data "aws_security_group" "endpoints_security_group" {
  name   = "${local.base_prefix}-vpc-endpoints-security-group"
  vpc_id = data.aws_vpc.spoke_vpc.id
}

data "aws_iam_role" "sagemaker_role" {
  name = local.sagemaker_role_name
}


</content>

<content full_path="bedrock-kb/outputs.tf">
output "knowledge_base_id" {
  value = aws_bedrockagent_knowledge_base.kb.id
}
</content>

<content full_path="bedrock-kb/locals.tf">
locals {
  resource_provisioner               = "UAIS"
  base_prefix                        = "uais-${split("-", var.project_id)[0]}"
  bedrock_kb_role_name               = "${local.base_prefix}-bedrock-kb-role"
  kb_name                            = "${local.base_prefix}-kb"
  data_source_name                   = "${local.base_prefix}-kb-data-source"
  opensearch_collection_name         = "${local.base_prefix}-kb-os-collection"
  opensearch_kb_index_name           = "${local.base_prefix}-kb-os-index"
  opensearch_encryption_policy_name  = "${local.base_prefix}-kb-os-security"
  opensearch_network_policy_name     = "${local.base_prefix}-kb-os-network"
  opensearch_data_access_policy_name = "${local.base_prefix}-kb-os-data-access"
  opensearch_vpc_endpoint_name       = "${local.base_prefix}-kb-os-vpc-endpoint"
  raw_data_bucket_name               = "${local.base_prefix}-workspace-bucket"
  kms_key_alias                      = "alias/${local.base_prefix}-kms-key"
  sagemaker_role_name                = "${local.base_prefix}-sagemaker-domain-exec-role"
}
</content>

<content full_path="bedrock-kb/main.tf">
# OpenSearch Serverless collection
resource "aws_opensearchserverless_collection" "kb_vector_store" {
  name = local.opensearch_collection_name
  type = "VECTORSEARCH"

  depends_on = [aws_opensearchserverless_security_policy.aoss_encryption_policy]
}

# OpenSearch Serverless encryption policy
resource "aws_opensearchserverless_security_policy" "aoss_encryption_policy" {
  name        = local.opensearch_encryption_policy_name
  type        = "encryption"
  description = "encryption security policy using customer KMS key"
  policy = jsonencode({
    Rules = [
      {
        Resource = [
          "collection/${local.opensearch_collection_name}"
        ],
        ResourceType = "collection"
      }
    ],
    AWSOwnedKey = false
    KmsARN      = data.aws_kms_key.base_kms_key.arn
  })
}

# OpenSearch Serverless network policy
resource "aws_opensearchserverless_security_policy" "aoss_network_policy" {
  name        = local.opensearch_network_policy_name
  type        = "network"
  description = "Allow Bedrock and VPC access to collection"
  policy = jsonencode([
    {
      Description = "Allow Bedrock and VPC access",
      Rules = [
        {
          ResourceType = "collection",
          Resource = [
            "collection/${local.opensearch_collection_name}"
          ]
        }
      ],
#       SourceServices = [
#         "bedrock.amazonaws.com"
#       ],
#       SourceVPCEs = [
#         aws_opensearchserverless_vpc_endpoint.aoss_vpc_endpoint.id
#       ],
      AllowFromPublic = true
    }
  ])
}

# OpenSearch Serverless data access policy
resource "aws_opensearchserverless_access_policy" "aoss_data_access_policy" {
  name        = local.opensearch_data_access_policy_name
  type        = "data"
  description = "allow index and collection access"
  policy = jsonencode([
    {
      Rules = [
        {
          ResourceType = "index",
          Resource = [
            "index/${local.opensearch_collection_name}/*"
          ],
          Permission = [
            "aoss:*"
          ]
        },
        {
          ResourceType = "collection",
          Resource = [
            "collection/${local.opensearch_collection_name}"
          ],
          Permission = [
            "aoss:*"
          ]
        }
      ],
      Principal = [
        data.aws_iam_role.sagemaker_role.arn,
        data.aws_iam_role.bedrock_kb_role.arn,
        data.aws_caller_identity.current.arn
      ]
    }
  ])
}

# Creates a aoss VPC endpoint
resource "aws_opensearchserverless_vpc_endpoint" "aoss_vpc_endpoint" {
  name               = local.opensearch_vpc_endpoint_name
  vpc_id             = data.aws_vpc.spoke_vpc.id
  subnet_ids         = data.aws_subnets.endpoints_subnets.ids
  security_group_ids = [data.aws_security_group.endpoints_security_group.id]
}

# Bedrock Knowledge Base
resource "aws_bedrockagent_knowledge_base" "kb" {
  name     = local.kb_name
  role_arn = data.aws_iam_role.bedrock_kb_role.arn

  knowledge_base_configuration {
    vector_knowledge_base_configuration {
      embedding_model_arn = var.embedding_model_arn
    }
    type = "VECTOR"
  }

  storage_configuration {
    type = "OPENSEARCH_SERVERLESS"
    opensearch_serverless_configuration {
      collection_arn    = aws_opensearchserverless_collection.kb_vector_store.arn
      vector_index_name = local.opensearch_kb_index_name
      field_mapping {
        vector_field   = "bedrock-knowledge-base-default-vector"
        text_field     = "AMAZON_BEDROCK_TEXT_CHUNK"
        metadata_field = "AMAZON_BEDROCK_METADATA"
      }
    }
  }
  depends_on = [opensearch_index.sample_kb_index]
}

provider "opensearch" {
  url         = aws_opensearchserverless_collection.kb_vector_store.collection_endpoint
  healthcheck = false
}

resource "opensearch_index" "sample_kb_index" {
  name                           = local.opensearch_kb_index_name
  number_of_shards               = "2"
  number_of_replicas             = "0"
  index_knn                      = true
  index_knn_algo_param_ef_search = "512"
  mappings                       = <<-EOF
    {
      "properties": {
        "bedrock-knowledge-base-default-vector": {
          "type": "knn_vector",
          "dimension": 1024,
          "method": {
            "name": "hnsw",
            "engine": "faiss",
            "parameters": {
              "m": 16,
              "ef_construction": 512
            },
            "space_type": "l2"
          }
        },
        "AMAZON_BEDROCK_METADATA": {
          "type": "text",
          "index": "false"
        },
        "AMAZON_BEDROCK_TEXT_CHUNK": {
          "type": "text",
          "index": "true"
        }
      }
    }
  EOF
  force_destroy                  = true
}

resource "aws_bedrockagent_data_source" "kb_data_source" {
  knowledge_base_id = aws_bedrockagent_knowledge_base.kb.id
  name              = local.data_source_name

  data_source_configuration {
    type = "S3"
    s3_configuration {
      bucket_arn = data.aws_s3_bucket.raw_data_bucket.arn
      inclusion_prefixes = [
        "default-kb-space/"
      ]
    }
  }
}


</content>

<content full_path="bedrock-kb/param_store_values.tf">
resource "aws_ssm_parameter" "default_kb_id" {
  name  = "/params/${local.base_prefix}/platform/default-kb-id"
  type  = "String"
  value = aws_bedrockagent_knowledge_base.kb.id

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
    }
  )
}

resource "aws_ssm_parameter" "default_data_source_id" {
  name  = "/params/${local.base_prefix}/platform/default-kb-datasource-id"
  type  = "String"
  value = aws_bedrockagent_data_source.kb_data_source.id

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
    }
  )
}

resource "aws_ssm_parameter" "default_aoss_collection_arn" {
  name  = "/params/${local.base_prefix}/platform/default-aoss-collection-arn"
  type  = "String"
  value = aws_opensearchserverless_collection.kb_vector_store.arn

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
    }
  )
}

resource "aws_ssm_parameter" "default_aoss_endpoint" {
  name  = "/params/${local.base_prefix}/platform/default-aoss-endpoint"
  type  = "String"
  value = aws_opensearchserverless_collection.kb_vector_store.collection_endpoint

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
    }
  )
}
</content>

<content full_path="bedrock-kb/variables.tf">
variable "aws_region" {
  description = "AWS Region."
  type        = string
  default     = "us-east-1"
}

variable "tags" {
  description = "Tags to apply to resources."
  type        = map(string)
}

variable "aws_account_id" {
  description = "AWS Account ID"
  type        = string
}

variable "project_id" {
  description = "UAIS Project ID tied to the workspace"
  type        = string
}

variable "embedding_model_arn" {
  description = "ARN of the embedding model to use for the knowledge base"
  type        = string
  default     = "arn:aws:bedrock:us-east-1::foundation-model/amazon.titan-embed-text-v2:0"
}
</content>

<content full_path="bedrock-kb/provider.tf">
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
    opensearch = {
      source  = "opensearch-project/opensearch"
      version = "= 2.3.2"
    }
  }
#   backend "s3" {
#     access_key = ""
#     secret_key = ""
#     token      = ""
#     bucket     = ""
#     key        = ""
#     region     = ""
#   }
}

provider "aws" {

  #   access_key = var.aws_access_key
  #   secret_key = var.aws_secret_key
  region = var.aws_region
  #
  #   assume_role {
  #     role_arn = "arn:aws:iam::${var.aws_account_id}:role/uais_admin_access_role"
  #   }
}
</content>

<content full_path="bedrock-kb/inputs/sandbox/982534393096_46de60f5-2b31-4fb7-9cbf-b728d5b104e3.tfvars">
aws_region     = "us-east-1"
aws_account_id = "982534393096"
project_id     = "46de60f5-2b31-4fb7-9cbf-b728d5b104e3"

tags = {
  "project_id"   = "46de60f5-2b31-4fb7-9cbf-b728d5b104e3",
  "aide-id"      = "AIDE_0074310"
  "hcp_rg"       = "migration-aide-0074310-4416a57",
  "environment"  = "dev",
  "service-tier" = "p2"
}
</content>

<content full_path="lambda/data.tf">
data "aws_caller_identity" "current" {}

data "aws_region" "current" {}

data "aws_iam_policy" "AmazonSageMakerFullAccess" {
  name = "AmazonSageMakerFullAccess"
}
</content>

<content full_path="lambda/outputs.tf">
# Lambda Function
output "lambda_function_arn" {
  description = "The ARN of the Lambda Function"
  value       = try(aws_lambda_function.my_lambda_function.arn, "")
}

</content>

<content full_path="lambda/main.tf">
resource "aws_iam_role" "lambda_role" {
  name = "${var.project_id}-lambda-execution-role"
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })
}

resource "aws_iam_role_policy" "lambda_logs_policy" {
  name = "${var.project_id}-lambda-logs-policy"
  role = aws_iam_role.lambda_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect   = "Allow"
        Action   = "logs:CreateLogGroup"
        Resource = "arn:aws:logs:${var.lambda_aws_region}:${var.lambda_aws_account_id}:*"
      },
      {
        Effect = "Allow"
        Action = [
          "logs:CreateLogStream",
          "logs:PutLogEvents"
        ]
        Resource = [
          "arn:aws:logs:${var.lambda_aws_region}:${var.lambda_aws_account_id}:log-group:/aws/lambda/*"
        ]
      }
    ]
  })
}

resource "aws_iam_role_policy" "lambda_sagemaker_policy" {
  name = "${var.project_id}-lambda-execution-role-policy"
  role = aws_iam_role.lambda_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect   = "Allow"
        Action   = "sagemaker:InvokeEndpoint"
        Resource = "arn:aws:sagemaker:${var.lambda_aws_region}:${var.lambda_aws_account_id}:*"
      }
    ]
  })
}

resource "aws_lambda_function" "my_lambda_function" {
  filename         = "./lambda_function.zip"
  description      = "This Lambda Function is used to Invoke the Model Endpoint for the given Model Endpoint name, Inference Component Name and the Request body"
  function_name    = "lambda_fn_Invoke_Endpoint"
  role             = aws_iam_role.lambda_role.arn
  handler          = "lambda_function.lambda_handler"
  runtime          = "python3.9"
  source_code_hash = filebase64sha256("lambda_function.zip")

  layers = [
    "arn:aws:lambda:us-east-1:017000801446:layer:AWSLambdaPowertoolsPythonV2:46"
  ]
  timeout = 300
}

</content>

<content full_path="lambda/lambda_function.zip">
PK   Z               lambda_function.pyux ö     UT
 VïøgWïøgVïøg­RQoÚ0~Ï¯°xq2AVmÚ-¢ÓFªÁ[pëØí°¢ÿ¾³I ©Z¡IóK»ï;ßwß¢ÔÆm#qº­µÓ_'«Usz»jE¦RN@F'lKÊÅ´§m¡`Ï`hE±5=ÝûbqR'S!ØÌtv!ÃHV¬9[íâ9S®Or­¼¸d<;`ÅG^Ã¿?ô6ÏÁÚÁFËÁ­úÏ 3 CB?Ñþì÷SUö	|w°8p÷ÜNóÀËÓl6ï?dó
´c>Îç2~È+ë*G	Aá#]k~ ËèªG%ÔFÇÞoÈAìólFNÜ!ymU:öÙ-µ²Þ²Æ$¡öúV x©ºwÆú3©£3VÀ¨n¨£Ë~ïçPºee)EÎÐê³ïvaõý¯bïPÿÈÇS^¥[Ò.rª6`@å0Ö¸¨
ºmw³tùÎtV~æ8¢ðªÔÛ¸I=Ò»àGjp)â$åkq|èÏtª¿qÅUFµv6ìuÌUvåq¾ÜÜtÅÒÝy+ëÛ|Ø!iM®[?°§J:uëàiõÎÂ7LÂ]#Ì¸lqiümzc´AÝèUüz¿ý½|¬[h)ùPK4ëÿR  î  PK   Z4ëÿR  î                lambda_function.pyux ö     UT VïøgPK      X   c    
</content>

<content full_path="lambda/variables.tf">
variable "lambda_aws_region" {
  description = "AWS Region."
  type        = string
  default     = "us-east-1"
}

variable "lambda_aws_account_id" {
  description = "AWS Account Id."
  type        = string
  default     = "982534393096"
}

variable "project_id" {
  description = "Project ID"
  type        = string
}
</content>

<content full_path="lambda/provider.tf">
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }

}

provider "aws" {

  #   access_key = var.aws_access_key
  #   secret_key = var.aws_secret_key
  region     = var.lambda_aws_region
  #
  #   assume_role {
  #     role_arn = "arn:aws:iam::${var.aws_account_id}:role/uais_admin_access_role"
  #   }
}
</content>

<content full_path="lambda/lambda-function/lambda_function.py">
import os
import boto3
import json
import logging

runtime = boto3.client('runtime.sagemaker')

logger = logging.getLogger()
logger.setLevel(logging.INFO)

def lambda_handler(event, context):
    headers = {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type',
        'Access-Control-Allow-Methods': 'OPTIONS,POST'
    }

    try:
        json_string = event['body']

        logger.info(f"Received JSON string: {json_string}")

        response = runtime.invoke_endpoint(
            EndpointName=event['EndpointName'],
            Accept='application/json',
            ContentType='application/json',
            Body=json.dumps(json_string),
            InferenceComponentName=event['inferenceComponentName'])

        response_body = json.loads(response['Body'].read().decode())
        logger.info(f"Response: {response_body}")

        return {
            'statusCode': 200,
            'headers': headers,
            'body': json.dumps({
                'result': response_body
            })
        }

    except Exception as e:
        print(f"Error: {str(e)}")
        return {
            'statusCode': 500,
            'headers': headers,
            'body': json.dumps({'error': str(e)})
        }
</content>

<content full_path="lambda/inputs/lambda-invoke-endpoint.tfvars">
lambda_aws_region = "us-east-1"
lambda_aws_account_id = "982534393096"
project_id = "uais-test-terraform-testprj-id"

</content>

<content full_path="base/role_sagemaker.tf">
resource "aws_iam_role" "sagemaker_domain_default_execution_role" {
  name               = "${local.base_prefix}-sagemaker-domain-exec-role"
  path               = "/"
  assume_role_policy = data.aws_iam_policy_document.sagemaker_domain_assume_role_policy.json
}

# Allows access to sagemaker s3 get, put and list
# Allows access to sagemaker ecr get, put,
# Allows only model training and block all model deployment activities
resource "aws_iam_policy" "sagemaker_execution_policy" {
  name        = local.sagemaker_policy_name
  description = "Policy to allow model training in SageMaker, access to specified S3 and ECR resources"
  policy      = local.sagemaker_policy
}

resource "aws_iam_role_policy_attachment" "attach_policy" {
  role       = aws_iam_role.sagemaker_domain_default_execution_role.name
  policy_arn = aws_iam_policy.sagemaker_execution_policy.arn
}

# Attaching the AmazonSageMakerFullAccess policy to the SageMaker execution role
# Model creation and deployment is blocked by the custom deny policy above
resource "aws_iam_role_policy_attachment" "attach_sagemaker_policy" {
  role       = aws_iam_role.sagemaker_domain_default_execution_role.name
  policy_arn = data.aws_iam_policy.AmazonSageMakerFullAccess.arn
}

resource "aws_iam_role_policy_attachment" "attach_sagemaker_canvas_policy" {
  role       = aws_iam_role.sagemaker_domain_default_execution_role.name
  policy_arn = data.aws_iam_policy.AmazonSageMakerCanvasFullAccess.arn
}

resource "aws_iam_role_policy_attachment" "attach_sagemaker_canvas_services_policy" {
  role       = aws_iam_role.sagemaker_domain_default_execution_role.name
  policy_arn = data.aws_iam_policy.AmazonSageMakerCanvasAIServicesAccess.arn
}

resource "aws_iam_role_policy_attachment" "attach_bedrock_policy" {
  role       = aws_iam_role.sagemaker_domain_default_execution_role.name
  policy_arn = data.aws_iam_policy.bedrock_full_access.arn
}
</content>

<content full_path="base/data.tf">
data "aws_caller_identity" "current" {}

data "aws_region" "current" {}

# Sagemaker specific data blocks
data "aws_iam_policy" "bedrock_full_access" {
  name = "AmazonBedrockFullAccess"
}

data "aws_iam_policy" "AmazonSageMakerFullAccess" {
  name = "AmazonSageMakerFullAccess"
}

data "aws_iam_policy" "AmazonSageMakerCanvasFullAccess" {
  name = "AmazonSageMakerCanvasFullAccess"
}

data "aws_iam_policy" "AmazonSageMakerCanvasAIServicesAccess" {
  name = "AmazonSageMakerCanvasAIServicesAccess"
}

data "aws_iam_policy_document" "sagemaker_domain_assume_role_policy" {
  statement {
    actions = ["sts:AssumeRole"]

    principals {
      type        = "Service"
      identifiers = ["sagemaker.amazonaws.com"]
    }
  }
}

data "aws_iam_policy_document" "lex_assume_role_policy" {
  statement {
    actions = ["sts:AssumeRole"]

    principals {
      type        = "Service"
      identifiers = ["lexv2.amazonaws.com"]
    }
  }
}


data "aws_iam_policy_document" "glue_assume_role_policy" {
  statement {
    actions = ["sts:AssumeRole"]

    principals {
      type        = "Service"
      identifiers = ["glue.amazonaws.com"]
    }
  }
}

data "aws_iam_policy_document" "bedrock_assume_role_policy" {
  statement {
    actions = ["sts:AssumeRole"]

    principals {
      type        = "Service"
      identifiers = ["bedrock.amazonaws.com"]
    }
  }
}

data "aws_iam_policy_document" "opensearch_master_assume_role_policy" {
  statement {
    actions = ["sts:AssumeRole"]
    
    principals {
      type        = "AWS"
      identifiers = ["arn:aws:iam::${data.aws_caller_identity.current.account_id}:root"]
    }
  }
}

</content>

<content full_path="base/outputs.tf">
# VPC outputs
output "vpc_id" {
  value       = module.spoke_vpc.vpc_attributes.id
  description = "The ID of the VPC"
}

# Security Group outputs
output "sagemaker_sg_id" {
  value       = aws_security_group.sagemaker_sg.id
  description = "The ID of the SageMaker security group"
}

output "lambda_sg_id" {
  value       = aws_security_group.lambda_sg.id
  description = "The ID of the Lambda security group"
}

output "opensearch_sg_id" {
  value       = aws_security_group.opensearch_sg.id
  description = "The ID of the OpenSearch security group"
}

# KMS outputs
output "base_kms_key_id" {
  value       = aws_kms_key.base_kms_key.id
  description = "The ID of the base KMS key"
}

output "base_kms_key_arn" {
  value       = aws_kms_key.base_kms_key.arn
  description = "The ARN of the base KMS key"
}

# ECR outputs
output "base_ecr_repository_url" {
  value       = aws_ecr_repository.base_ecr_repository.repository_url
  description = "The URL of the base ECR repository"
}

output "base_ecr_repository_arn" {
  value       = aws_ecr_repository.base_ecr_repository.arn
  description = "The ARN of the base ECR repository"
}

</content>

<content full_path="base/locals.tf">
locals {
  optum_ip_whitelist = ["168.183.0.0/16", "149.111.0.0/16", "128.35.0.0/16", "161.249.0.0/16", "198.203.174.0/23",
  "198.203.176.0/22", "198.203.180.0/23"]
  resource_provisioner = "UAIS"
  base_prefix          = "uais-${split("-", var.project_id)[0]}"
  kms_key_alias        = "alias/${local.base_prefix}-kms-key"

  # Generic Policy locals
  policy_template_path = "${path.module}/policies"
  policy_arn_prefix    = "arn:aws:%s:${var.aws_region}:${var.aws_account_id}"

  # Lambda Policy locals
  policy_lambda_template_path = "${local.policy_template_path}/lambda"

  policy_lambda_base_name       = "${local.base_prefix}-lambda-base-policy"
  policy_lambda_data_name       = "${local.base_prefix}-lambda-data-storage-policy"
  policy_lambda_ai_name         = "${local.base_prefix}-lambda-ai-services-policy"
  policy_lambda_secret_name     = "${local.base_prefix}-lambda-secret-config-policy"
  policy_lambda_monitoring_name = "${local.base_prefix}-lambda-monitoring-policy"


  policy_lambda_arn_ssm_read  = format("${local.policy_arn_prefix}:parameter/params/${local.base_prefix}/platform/*", "ssm")    # Eg: arn:aws:ssm:us-east-1:952189540345:parameter/params/lambda/uais-c6945420*
  policy_lambda_arn_ssm_write = format("${local.policy_arn_prefix}:parameter/params/${local.base_prefix}/application/*", "ssm") # Eg: arn:aws:ssm:us-east-1:952189540345:parameter/params/lambda/uais-c6945420*

  policy_lambda_arn_neptune_write = format("${local.policy_arn_prefix}:cluster:${local.base_prefix}", "rds") # Eg:  arn:aws:rds:us-east-1:952189540345:cluster:uaispocws-neptune-db

  policy_lambda_arn_dynamodb = format("${local.policy_arn_prefix}:table/${local.base_prefix}-*", "dynamodb") # Eg: arn:aws:dynamodb:us-east-1:952189540345:table/uais-b4854dd4-employee*

  lambda_policy_base = templatefile("${local.policy_lambda_template_path}/base.json.tpl", {})
  ddb_table_prefix = "${local.base_prefix}-"
  lambda_policy_data = templatefile("${local.policy_lambda_template_path}/data.json.tpl", {
    dynamodb_resource_arn = local.policy_lambda_arn_dynamodb
    lambda_resource_arn = local.lambda_resource_arn
    table_prefix = local.ddb_table_prefix
  })

  lambda_policy_secret = templatefile("${local.policy_lambda_template_path}/secret.json.tpl", {
    param_store_resource_arn_read  = local.policy_lambda_arn_ssm_read,
    param_store_resource_arn_write = local.policy_lambda_arn_ssm_write
  })

  lambda_policy_ai = templatefile("${local.policy_lambda_template_path}/ai.json.tpl", {
    neptune_resource_arn = local.policy_lambda_arn_neptune_write,
  })

  lambda_policy_monitoring = templatefile("${local.policy_lambda_template_path}/monitoring.json.tpl", {})

  role_lambda_exec_role = "${local.base_prefix}-lambda-domain-exec-role"

  # Lambda Resource Arn
  lambda_resource_arn = format("${local.policy_arn_prefix}:function:${local.base_prefix}-*", "lambda") # e.g. arn:aws:lambda:your-region:your-account-id:function:uais-c6945420*

  sagemaker_policy_name = "${local.base_prefix}-sagemaker-execution-policy"
  sagemaker_policy = templatefile("${path.module}/policies/sagemaker/sagemaker_custom.tpl", {
    workspace_bucket_arn          = module.s3_bucket.workspace_bucket_arn
    byod_bucket_arn               = module.s3_bucket.byod_bucket_arn
    base_ecr_arn                  = aws_ecr_repository.base_ecr_repository.arn
    sagemaker_role_arn            = aws_iam_role.sagemaker_domain_default_execution_role.arn
    base_kms_arn                  = aws_kms_key.base_kms_key.arn
    aoss_arn                      = "arn:aws:aoss:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:collection/*"
    param_store_resource_arn_read = local.policy_lambda_arn_ssm_read
  })

  bedrock_kb_role_name   = "${local.base_prefix}-bedrock-kb-role"
  bedrock_kb_policy_name = "${local.base_prefix}-bedrock-kb-policy"
  bedrock_kb_policy = templatefile("${path.module}/policies/bedrock_kb/bedrock_kb_custom.tpl", {
    workspace_bucket_arn = module.s3_bucket.workspace_bucket_arn
    aoss_arn             = "arn:aws:aoss:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:collection/*"
    embedding_model_arn  = "arn:aws:bedrock:us-east-1::foundation-model/*"
    base_kms_arn         = aws_kms_key.base_kms_key.arn
  })

  lex_lambda_resource_arn    = format("${local.policy_arn_prefix}:function:${local.base_prefix}*", "lambda")
  lex_logs_resource_arn      = format("${local.policy_arn_prefix}:log-group:/aws/lex/${local.base_prefix}-lex:*", "logs")

  lex_policy = templatefile("${path.module}/policies/lex/lex.tpl", {
    lex_lambda_resource_arn = local.lex_lambda_resource_arn
    lex_logs_resource_arn   = local.lex_logs_resource_arn
  })

  policy_lex_base = "${local.base_prefix}-lex-service-policy"
  role_lex        = "${local.base_prefix}-lex-service-role"

  policy_glue_base  = "${local.base_prefix}-glue-base-policy"
  role_glue         = "${local.base_prefix}-glue-exec-role"
  glue_catalog      = format("${local.base_prefix}-glue-catalog")

  glue_policy = templatefile("${path.module}/policies/glue/glue.tpl", {
    workspace_bucket_arn                                      = module.s3_bucket.workspace_bucket_arn
    service_bucket_arn                                        = module.s3_bucket.service_bucket_arn
    glue_catalog_database_arn                                 = format("${local.policy_arn_prefix}:%s/${local.glue_catalog}", "glue", "database")
    glue_catalog_table_arn                                    = format("${local.policy_arn_prefix}:%s/${local.glue_catalog}", "glue", "table")
    glue_log_group_arn                                        = format("${local.policy_arn_prefix}:log-group:/aws-glue/*", "logs")
    param_store_allow_catalog_read_and_create_for_crawler_arn = format("${local.policy_arn_prefix}:catalog", "glue")
  })

  opensearch_policy_name = "${local.base_prefix}-opensearch-master-policy"
  opensearch_domain_arn = format("${local.policy_arn_prefix}:domain/${local.base_prefix}-opensearch/*", "es")
  opensearch_master_policy = templatefile("${path.module}/policies/opensearch/opensearch_master.tpl", {
    opensearch_domain_arn = local.opensearch_domain_arn
    base_kms_arn         = aws_kms_key.base_kms_key.arn
  })
}
</content>

<content full_path="base/roles_lambda.tf">
# The lambda policy for its execution
resource "aws_iam_policy" "lambda_exec_policy_base" {
  name        = local.policy_lambda_base_name
  description = "The lambda policy for its execution"
  policy      = local.lambda_policy_base
}

# The lambda policy for accessing data (eg: dynamodb, s3 etc.)
resource "aws_iam_policy" "lambda_exec_policy_data" {
  name        = local.policy_lambda_data_name
  description = "The lambda exec policy for accessing data (eg: dynamodb, s3 etc.)"
  policy      = local.lambda_policy_data
}

# The lambda policy for accessing ai services (eg: Bedrock, OSS, etc.)
resource "aws_iam_policy" "lambda_exec_policy_ai" {
  name        = local.policy_lambda_ai_name
  description = "The lambda exec policy for accessing ai services (eg: Bedrock, OSS, etc.)"
  policy      = local.lambda_policy_ai
}

# The lambda policy for accessing secrets (eg: KMS, Parameter Store, etc.)
resource "aws_iam_policy" "lambda_exec_policy_secrets" {
  name        = local.policy_lambda_secret_name
  description = "The lambda policy for accessing secrets (eg: KMS, Parameter Store, etc.)"
  policy      = local.lambda_policy_secret
}

# The lambda policy for accessing monitoring services (eg: cloudwatch, xray , etc.)
resource "aws_iam_policy" "lambda_exec_policy_monitoring" {
  name        = local.policy_lambda_monitoring_name
  description = "The lambda policy for accessing monitoring services (eg: cloudwatch, xray , etc.)"
  policy      = local.lambda_policy_monitoring
}

# Creating the role
resource "aws_iam_role" "lambda_exec_role" {
  name = local.role_lambda_exec_role

  assume_role_policy = jsonencode({
    Version = "2012-10-17",
    Statement = [
      {
        Action = "sts:AssumeRole",
        Effect = "Allow",
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })
}


# Attaching the base policy
resource "aws_iam_role_policy_attachment" "base_policy_attachment" {
  role       = aws_iam_role.lambda_exec_role.name
  policy_arn = aws_iam_policy.lambda_exec_policy_base.arn
}

# Attaching the ai policy
resource "aws_iam_role_policy_attachment" "ai_policy_attachment" {
  role       = aws_iam_role.lambda_exec_role.name
  policy_arn = aws_iam_policy.lambda_exec_policy_ai.arn
}

# Attaching the data policy
resource "aws_iam_role_policy_attachment" "data_policy_attachment" {
  role       = aws_iam_role.lambda_exec_role.name
  policy_arn = aws_iam_policy.lambda_exec_policy_data.arn
}

# Attaching the monitoring policy
resource "aws_iam_role_policy_attachment" "monitoring_policy_attachment" {
  role       = aws_iam_role.lambda_exec_role.name
  policy_arn = aws_iam_policy.lambda_exec_policy_monitoring.arn
}

# Attaching the secret policy
resource "aws_iam_role_policy_attachment" "secret_policy_attachment" {
  role       = aws_iam_role.lambda_exec_role.name
  policy_arn = aws_iam_policy.lambda_exec_policy_secrets.arn
}

</content>

<content full_path="base/main.tf">
# Creates a vpc with subnets, route tables for the workspace.
# Adds a tag np_ready_to_reroute to true for HCP scheduler to reroute traffic to firewall by adding a route to the route tables created.
module "spoke_vpc" {
  source     = "aws-ia/vpc/aws"
  version    = "= 4.4.4"
  name       = "${local.base_prefix}-vpc"
  cidr_block = var.vpc.cidr_block
  az_count   = var.vpc.number_azs
  subnets = {
    sagemaker_subnet = {
      name_prefix = "${local.base_prefix}-sagemaker"
      cidrs       = var.vpc.sagemaker_subnet_cidrs
    }

    endpoints_subnet = {
      name_prefix = "${local.base_prefix}-endpoints"
      cidrs       = var.vpc.endpoint_subnet_cidrs
    }
  }
  tags = merge(
    var.tags,
    {
      provisoner          = local.resource_provisioner
      name                = "${local.base_prefix}-vpc"
      np_ready_to_reroute = "true"
    }
  )
}

resource "aws_security_group" "sagemaker_sg" {
  name        = "${local.base_prefix}-sagemaker-sg"
  description = "Allow certain NFS and TCP inbound traffic"
  vpc_id      = module.spoke_vpc.vpc_attributes.id

  # restricting access from optum tower ips
  ingress {
    description = "Ingress access only with in optum tower ips"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = local.optum_ip_whitelist
  }

  ingress {
    description = "NFS traffic over TCP on port 2049 between the domain and EFS volume"
    from_port   = 2049
    to_port     = 2049
    protocol    = "tcp"
    self        = true
  }

  ingress {
    description = "TCP traffic between JupyterServer app and the KernelGateway apps"
    from_port   = 8192
    to_port     = 65535
    protocol    = "tcp"
    self        = true
  }

  # By default, AWS creates an ALLOW ALL egress rule when creating a new Security Group inside of a VPC.
  # When creating a new Security Group inside a VPC, Terraform will remove this default rule,
  # and require you specifically re-create it if you desire that rule.
  egress {
    description      = "Allow outbound traffic"
    from_port        = 0
    to_port          = 0
    protocol         = "-1" # semantically equivalent to all ports
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
      name       = "${local.base_prefix}-sagemaker-sg"
    }
  )
}

# Lambda Security Group
resource "aws_security_group" "lambda_sg" {
  name        = "${local.base_prefix}-lambda-sg"
  description = "Security group for Lambda functions"
  vpc_id      = module.spoke_vpc.vpc_attributes.id

  # Allow all outbound traffic by default
  egress {
    description      = "Allow all outbound traffic"
    from_port        = 0
    to_port          = 0
    protocol         = "-1"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
      name       = "${local.base_prefix}-lambda-sg"
    }
  )
}

# OpenSearch Security Group - without inline rules to avoid circular dependency
resource "aws_security_group" "opensearch_sg" {
  name        = "${local.base_prefix}-opensearch-sg"
  description = "Security group for OpenSearch domain within project VPC"
  vpc_id      = module.spoke_vpc.vpc_attributes.id

  ingress {
    description = "HTTPS access from Lambda functions"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    security_groups = [aws_security_group.lambda_sg.id]
  }

  ingress {
    description = "HTTPS access from SageMaker domain"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    security_groups = [aws_security_group.sagemaker_sg.id]
  }

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
      name       = "${local.base_prefix}-opensearch-sg"
    }
  )
}

# Kms key which will be used for SSE encryption resources in this workspace.
resource "aws_kms_key" "base_kms_key" {
  description         = "KMS key used to encrypt S3 and workspace resources"
  enable_key_rotation = true
}

resource "aws_kms_alias" "my_key_alias" {
  name          = local.kms_key_alias
  target_key_id = aws_kms_key.base_kms_key.key_id
}

resource "aws_kms_key_policy" "base_kms_key_policy" {
  key_id = aws_kms_key.base_kms_key.id
  policy = jsonencode({
    Id = "base_worksapce_key_policy"
    Statement = [
      {
        Action = "kms:*"
        Effect = "Allow"
        Principal = {
          AWS = [
            data.aws_caller_identity.current.account_id
          ]
        }
        Resource = "*"
        Sid      = "Enable all IAM role/user in this account to use this key"
      },
    ]
    Version = "2012-10-17"
  })
}

resource "aws_ecr_repository" "base_ecr_repository" {
  name                 = "${local.base_prefix}-ecr"
  image_tag_mutability = "MUTABLE"

  image_scanning_configuration {
    scan_on_push = true
  }
  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
      name       = "${local.base_prefix}-ecr"
    }
  )
}

resource "aws_cloudwatch_log_group" "lex_conversation_logs" {
  name              = "/aws/lex/${local.base_prefix}-lex"
  retention_in_days = 90

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
    }
  )
}

# Creates all s3 buckets required for this workspace.
module "s3_bucket" {
  source             = "./s3_bucket"
  bucket_prefix      = local.base_prefix
  kms_arn            = aws_kms_key.base_kms_key.arn
  tower_ips          = local.optum_ip_whitelist
  sagemaker_role_arn = aws_iam_role.sagemaker_domain_default_execution_role.arn
  tags               = merge(var.tags, { provisoner = local.resource_provisioner })
}

# Creates all VPC endpoints to the endpoint_names as input required for this workspace.
# Interface endpoints are created for passed services names.
# Gateway endpoint is created for S3.
module "vpc_endpoints" {
  source         = "./endpoints"
  vpc_name       = "${local.base_prefix}-vpc"
  vpc            = module.spoke_vpc
  vpc_cidr       = module.spoke_vpc.vpc_attributes.cidr_block
  endpoint_names = var.endpoint_names
  tags           = merge(var.tags, { provisoner = local.resource_provisioner })
}

</content>

<content full_path="base/roles_lex.tf">
resource "aws_iam_policy" "lex_service_policy_base" {
  name        = local.policy_lex_base
  description = "The lex policy for its execution"
  policy      = local.lex_policy

  depends_on = [ aws_cloudwatch_log_group.lex_conversation_logs ]
}

resource "aws_iam_role" "lex_service_role" {
  name               = local.role_lex
  assume_role_policy = data.aws_iam_policy_document.lex_assume_role_policy.json
}

resource "aws_iam_role_policy_attachment" "attach_lex_service_policy" {
  role       = aws_iam_role.lex_service_role.name
  policy_arn = aws_iam_policy.lex_service_policy_base.arn
}

</content>

<content full_path="base/param_store_values.tf">
# Parameter Store values addition
resource "aws_ssm_parameter" "workspace_bucket_arn" {
  name  = "/params/${local.base_prefix}/platform/workspace-bucket-arn"
  type  = "String"
  value = module.s3_bucket.workspace_bucket_arn

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
    }
  )
}

resource "aws_ssm_parameter" "byod_bucket_arn" {
  name  = "/params/${local.base_prefix}/platform/byod-bucket-arn"
  type  = "String"
  value = module.s3_bucket.byod_bucket_arn

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
    }
  )
}

resource "aws_ssm_parameter" "service_bucket_arn" {
  name  = "/params/${local.base_prefix}/platform/service-bucket-arn"
  type  = "String"
  value = module.s3_bucket.service_bucket_arn

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
    }
  )
}

resource "aws_ssm_parameter" "workspace_ecr_arn" {
  name  = "/params/${local.base_prefix}/platform/workspace-ecr-arn"
  type  = "String"
  value = aws_ecr_repository.base_ecr_repository.arn

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
    }
  )
}

resource "aws_ssm_parameter" "vpc_id" {
  name  = "/params/${local.base_prefix}/platform/vpc-id"
  type  = "String"
  value = module.spoke_vpc.vpc_attributes.id

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
    }
  )
}
</content>

<content full_path="base/roles_glue.tf">

resource "aws_iam_policy" "glue_exec_policy_base" {
  name        = local.policy_glue_base
  description = "The glue policy for its execution"
  policy      = local.glue_policy
}
#
resource "aws_iam_role" "glue_exec_role" {
  name                = local.role_glue
  assume_role_policy  = data.aws_iam_policy_document.glue_assume_role_policy.json
}

resource "aws_iam_role_policy_attachment" "attach_glue_exec_policy" {
  role       = aws_iam_role.glue_exec_role.name
  policy_arn = aws_iam_policy.glue_exec_policy_base.arn
}

</content>

<content full_path="base/variables.tf">
variable "aws_region" {
  description = "AWS Region."
  type        = string
  default     = "us-east-1"
}

variable "project_id" {
  description = "UAIS Project ID tied to the workspace"
  type        = string
}

variable "vpc" {
  description = "Base workspace VPC definition."
  type        = any
}

variable "endpoint_names" {
  type        = list(string)
  description = "List of VPC Endpoints Names to deploy"

  default = ["sagemaker.api", "sagemaker.runtime", "sagemaker.featurestore-runtime", "sts", "ecr.dkr", "ecr.api"]
}

variable "tags" {
  type        = map(string)
  description = "Tags to apply to resources."
}

variable "aws_account_id" {
  description = "AWS Account ID"
  type        = string
}
</content>

<content full_path="base/role_bedrock_kb.tf">
# IAM Role for Bedrock and Lambda
resource "aws_iam_role" "bedrock_kb_role" {
  name = local.bedrock_kb_role_name
  assume_role_policy = data.aws_iam_policy_document.bedrock_assume_role_policy.json
}

# IAM Policy for S3 and OpenSearch access
resource "aws_iam_policy" "bedrock_kb_policy" {
  name        = local.bedrock_kb_policy_name
  description = "Policy to allow bedrock knowledge base access to S3 and OpenSearch"
  policy      = local.bedrock_kb_policy
}

resource "aws_iam_role_policy_attachment" "attach_bedrock_kb_policy" {
  role       = aws_iam_role.bedrock_kb_role.name
  policy_arn = aws_iam_policy.bedrock_kb_policy.arn
}
</content>

<content full_path="base/provider.tf">
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
#   backend "s3" {
#     access_key = ""
#     secret_key = ""
#     token      = ""
#     bucket     = ""
#     key        = ""
#     region     = ""
#   }
}

provider "aws" {

  #   access_key = var.aws_access_key
  #   secret_key = var.aws_secret_key
  region = var.aws_region
  #
  #   assume_role {
  #     role_arn = "arn:aws:iam::${var.aws_account_id}:role/uais_admin_access_role"
  #   }
}
</content>

<content full_path="base/role_opensearch.tf">
resource "aws_iam_role" "opensearch_master_role" {
  name               = "${local.base_prefix}-opensearch-master-role"
  path               = "/"
  assume_role_policy = data.aws_iam_policy_document.opensearch_master_assume_role_policy.json

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
    }
  )
}

# Minimal IAM policy for OpenSearch master role (authentication only)
# Fine-grained access control handles authorization within OpenSearch
resource "aws_iam_policy" "opensearch_master_policy" {
  name        = local.opensearch_policy_name
  description = "Minimal policy for OpenSearch master role authentication"
  policy      = local.opensearch_master_policy

  tags = merge(
    var.tags,
    {
      provisoner = local.resource_provisioner
    }
  )
}

resource "aws_iam_role_policy_attachment" "attach_opensearch_master_policy" {
  role       = aws_iam_role.opensearch_master_role.name
  policy_arn = aws_iam_policy.opensearch_master_policy.arn
}
</content>

<content full_path="base/endpoints/data.tf">
# Current AWS Region
data "aws_region" "region" {}
</content>

<content full_path="base/endpoints/main.tf">
# VPC endpoints
resource "aws_vpc_endpoint" "endpoint" {
  for_each = toset(var.endpoint_names)

  vpc_id              = var.vpc.vpc_attributes.id
  service_name        = "com.amazonaws.${data.aws_region.region.name}.${each.value}"
  vpc_endpoint_type   = "Interface"
  subnet_ids          = values({ for k, v in var.vpc.private_subnet_attributes_by_az : split("/", k)[1] => v.id if split("/", k)[0] == "endpoints_subnet" })
  security_group_ids  = [aws_security_group.endpoints_vpc_sg.id]
  private_dns_enabled = true
  tags                = var.tags
}

# Security Group
resource "aws_security_group" "endpoints_vpc_sg" {
  name        = "${var.vpc_name}-endpoints-security-group"
  description = "VPC endpoint"
  vpc_id      = var.vpc.vpc_attributes.id
  tags        = var.tags
}

resource "aws_vpc_security_group_ingress_rule" "allowing_ingress_https" {
  security_group_id = aws_security_group.endpoints_vpc_sg.id

  from_port   = 443
  to_port     = 443
  ip_protocol = "tcp"
  cidr_ipv4   = var.vpc.vpc_attributes.cidr_block
  tags        = var.tags
}

resource "aws_vpc_endpoint" "vpc_s3_endpoint" {
  vpc_id            = var.vpc.vpc_attributes.id
  service_name      = "com.amazonaws.${data.aws_region.region.name}.s3"
  vpc_endpoint_type = "Gateway"
  tags              = var.tags
}

resource "aws_vpc_endpoint_route_table_association" "s3_vpce_route_table_association" {
  for_each        = var.vpc.rt_attributes_by_type_by_az.private
  route_table_id  = each.value.id
  vpc_endpoint_id = aws_vpc_endpoint.vpc_s3_endpoint.id
}

# Add a Gateway VPC Endpoint for DynamoDB
resource "aws_vpc_endpoint" "vpc_dynamodb_endpoint" {
  vpc_id            = var.vpc.vpc_attributes.id
  service_name      = "com.amazonaws.${data.aws_region.region.name}.dynamodb"
  vpc_endpoint_type = "Gateway"
  tags              = var.tags
}

# Associate the DynamoDB Gateway endpoint with private route tables
resource "aws_vpc_endpoint_route_table_association" "dynamodb_vpce_route_table_association" {
  for_each        = var.vpc.rt_attributes_by_type_by_az.private
  route_table_id  = each.value.id
  vpc_endpoint_id = aws_vpc_endpoint.vpc_dynamodb_endpoint.id
}

</content>

<content full_path="base/endpoints/variables.tf">
variable "vpc_name" {
  type        = string
  description = "Name of the VPC where the EC2 instance(s) are created."
}

variable "vpc" {
  type        = any
  description = "VPC resources."
}

variable "vpc_cidr" {
  type        = any
  description = "VPC CIDR Block"
}

variable "endpoint_names" {
  type        = list(string)
  description = "VPC Endpoint Names"
}

variable "tags" {
  type        = map(string)
  description = "Tags to apply to resources."
}
</content>

<content full_path="base/policies/glue/glue.tpl">
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "RestrictGlueDatabaseAndTableAccessForCrawler",
      "Effect": "Allow",
      "Action": [
        "glue:GetDatabase",
        "glue:GetTable",
        "glue:UpdateTable",
        "glue:CreateTable",
        "glue:GetPartitions"
      ],
      "Resource": [
        "${glue_catalog_database_arn}",
        "${glue_catalog_table_arn}/*"
      ]
    },
    {
      "Sid": "AllowCatalogLevelReadAndCreateAccessForCrawler",
      "Effect": "Allow",
      "Action": [
        "glue:GetDatabase",
        "glue:GetTable",
        "glue:CreateTable",
        "glue:GetPartitions"
      ],
      "Resource": "${param_store_allow_catalog_read_and_create_for_crawler_arn}"
    },
    {
      "Sid": "AllowS3AccessForGlueJob",
      "Effect": "Allow",
      "Action": [
        "s3:GetObject",
        "s3:PutObject",
        "s3:ListBucket"
      ],
      "Resource": [
        "${workspace_bucket_arn}",
        "${workspace_bucket_arn}/*",
        "${service_bucket_arn}/*"
      ]
    },
    {
      "Sid": "AllowCloudWatchLogsForGlueJob",
      "Effect": "Allow",
      "Action": [
        "logs:CreateLogGroup",
        "logs:CreateLogStream",
        "logs:PutLogEvents"
      ],
      "Resource": [
        "${glue_log_group_arn}"
      ]
    }
  ]
}
</content>

<content full_path="base/policies/lex/lex.tpl">
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "AllowLambdaInvocationForLex",
      "Effect": "Allow",
      "Action": "lambda:InvokeFunction",
      "Resource": "${lex_lambda_resource_arn}"
    },
    {
      "Sid": "AllowCloudWatchLogsForLex",
      "Effect": "Allow",
      "Action": [
        "logs:CreateLogGroup",
        "logs:CreateLogStream",
        "logs:PutLogEvents"
      ],
      "Resource": "${lex_logs_resource_arn}"
    }
  ]
}

</content>

<content full_path="base/policies/opensearch/opensearch_master.tpl">
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "AllowOpenSearchDomainAccess",
      "Effect": "Allow",
      "Action": [
        "es:*"
      ],
      "Resource": "${opensearch_domain_arn}"
    },
    {
      "Sid": "AllowOpenSearchServiceAccess",
      "Effect": "Allow",
      "Action": [
        "es:DescribeDomains",
        "es:ListTags",
        "es:DescribeDomainHealth"
      ],
      "Resource": "*"
    },
    {
      "Sid": "AllowKMSAccess",
      "Effect": "Allow",
      "Action": [
        "kms:Decrypt",
        "kms:GenerateDataKey",
        "kms:CreateGrant"
      ],
      "Resource": "${base_kms_arn}"
    }
  ]
}
</content>

<content full_path="base/policies/bedrock_kb/bedrock_kb_custom.tpl">
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "s3:GetObject",
        "s3:ListBucket",
        "s3:PutObject"
      ],
      "Resource": [
        "${workspace_bucket_arn}",
        "${workspace_bucket_arn}/*"
      ]
    },
    {
      "Effect": "Allow",
      "Action": [
        "aoss:APIAccessAll"
      ],
      "Resource": "${aoss_arn}"
    },
    {
      "Action": [
        "kms:Decrypt",
        "kms:GenerateDataKey",
        "kms:CreateGrant"
      ],
      "Effect": "Allow",
      "Resource": "${base_kms_arn}"
    },
    {
      "Sid": "BedrockInvokeModelStatement",
      "Effect": "Allow",
      "Action": [
        "bedrock:InvokeModel"
      ],
      "Resource": [
        "${embedding_model_arn}"
      ]
    }
  ]
}
</content>

<content full_path="base/policies/lambda/base.json.tpl">
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "logs:CreateLogGroup",
        "logs:CreateLogStream",
        "logs:PutLogEvents"
      ],
      "Resource": "*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "ec2:CreateNetworkInterface",
        "ec2:DescribeNetworkInterfaces",
        "ec2:DeleteNetworkInterface"
      ],
      "Resource": "*"
    }
  ]
}
</content>

<content full_path="base/policies/lambda/ai.json.tpl">
{
	"Version": "2012-10-17",
	"Statement": [
		{
			"Effect": "Deny",
			"Action": [
				"neptune-db:ManageStatistics",
				"neptune-db:ResetDatabase",
				"neptune-db:DeleteStatistics"
			],
			"Resource": "${neptune_resource_arn}"
		}
	]
}
</content>

<content full_path="base/policies/lambda/monitoring.json.tpl">
{
	"Version": "2012-10-17",
	"Statement": [
		{
			"Effect": "Deny",
			"Action": [
				"logs:DeleteSubscriptionFilter",
				"logs:DeleteIntegration",
				"logs:DeleteDeliveryDestinationPolicy",
				"logs:CreateLogStream",
				"logs:CreateLogAnomalyDetector",
				"logs:CancelExportTask",
				"logs:DeleteRetentionPolicy",
				"logs:DeleteTransformer",
				"logs:PutIndexPolicy",
				"logs:PutDataProtectionPolicy",
				"logs:UpdateAnomaly",
				"logs:DeleteDeliverySource",
				"logs:DeleteQueryDefinition",
				"logs:PutDeliverySource",
				"logs:CreateLogGroup",
				"logs:PutIntegration",
				"logs:Link",
				"logs:CreateLogDelivery",
				"logs:PutMetricFilter",
				"logs:PutResourcePolicy",
				"logs:UpdateLogDelivery",
				"logs:UpdateDeliveryConfiguration",
				"logs:PutDeliveryDestinationPolicy",
				"logs:PutSubscriptionFilter",
				"logs:DeleteDelivery",
				"logs:DeleteDataProtectionPolicy",
				"logs:CreateDelivery",
				"logs:DeleteLogStream",
				"logs:DeleteAccountPolicy",
				"logs:CreateExportTask",
				"logs:UpdateLogAnomalyDetector",
				"logs:DeleteResourcePolicy",
				"logs:DeleteMetricFilter",
				"logs:AssociateKmsKey",
				"logs:DeleteLogDelivery",
				"logs:DeleteLogAnomalyDetector",
				"logs:DeleteDeliveryDestination",
				"logs:PutDestination",
				"logs:DisassociateKmsKey",
				"logs:DeleteLogGroup",
				"logs:PutDestinationPolicy",
				"logs:PutQueryDefinition",
				"logs:DeleteDestination",
				"logs:PutAccountPolicy",
				"logs:PutLogEvents",
				"logs:PutDeliveryDestination",
				"logs:DeleteIndexPolicy",
				"logs:PutTransformer",
				"logs:PutRetentionPolicy"
			],
			"Resource": "*"
		}
	]
}
</content>

<content full_path="base/policies/lambda/secret.json.tpl">
{
	"Version": "2012-10-17",
	"Statement": [
		{
			"Sid": "ReadPermissionOnPlatformParameterStore",
			"Effect": "Allow",
			"Action": [
				"ssm:GetParametersByPath",
				"ssm:GetParameters",
				"ssm:GetParameter"
			],
			"Resource": "${param_store_resource_arn_read}"
		},
		{
			"Sid": "AllPermissionOnApplicationParameterStore",
			"Effect": "Allow",
			"Action": "ssm:*",
			"Resource": "${param_store_resource_arn_write}"
		},
		{
			"Sid": "DenyPermissionOnParameterStore",
			"Effect": "Deny",
			"Action": [
				"ssm:DeleteResourcePolicy",
				"ssm:PutResourcePolicy",
				"ssm:ModifyDocumentPermission"
			],
			"Resource": "${param_store_resource_arn_write}"
		}
	]
}
</content>

<content full_path="base/policies/lambda/data.json.tpl">
{
	"Version": "2012-10-17",
	"Statement": [
		{
			"Sid": "AllowDynamoDBFullAccess",
			"Effect": "Allow",
			"Action": "dynamodb:*",
			"Resource": "${dynamodb_resource_arn}",
			"Condition": {
				"ArnEquals": {
					"aws:SourceArn": "${lambda_resource_arn}"
				}
			}
		},
		{
			"Sid": "AllowCreateTable",
			"Effect": "Allow",
			"Action": "dynamodb:CreateTable",
			"Condition": {
				"ArnEquals": {
					"aws:SourceArn": "${lambda_resource_arn}"
				},
				"StringLike": {
					"dynamodb:TableName": "${table_prefix}*"
				}
			},
			"Resource": "*"
		}
	]
}
</content>

<content full_path="base/policies/sagemaker/sagemaker_custom.tpl">
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "AllowReadWriteDeleteAccessOnWorkspaceBucket",
      "Effect": "Allow",
      "Action": [
        "s3:Get*",
        "s3:List*",
        "s3:Describe*",
        "s3:DeleteObject",
        "s3:PutObject",
        "s3:PutObjectAcl"
      ],
      "Resource": [
        "${workspace_bucket_arn}",
        "${workspace_bucket_arn}/*"
      ]
    },
    {
      "Sid": "AllowReadAccessOnByodBucket",
      "Effect": "Allow",
      "Action": [
        "s3:Get*",
        "s3:List*",
        "s3:Describe*"
      ],
      "Resource": [
        "${byod_bucket_arn}",
        "${byod_bucket_arn}/*"
      ]
    },
    {
      "Sid": "AllowReadWriteAccessOnWorkspaceEcr",
      "Effect": "Allow",
      "Action": [
        "ecr:GetDownloadUrlForLayer",
        "ecr:BatchGetImage",
        "ecr:PutImage",
        "ecr:GetAuthorizationToken",
        "ecr:DescribeImages"
      ],
      "Resource": "${base_ecr_arn}"
    },
    {
      "Action": [
        "kms:Decrypt",
        "kms:GenerateDataKey",
        "kms:CreateGrant"
      ],
      "Effect": "Allow",
      "Resource": "${base_kms_arn}"
    },
    {
      "Sid": "AllowPassRoleToSageMaker",
      "Effect": "Allow",
      "Action": [
        "iam:PassRole"
      ],
      "Resource": "${sagemaker_role_arn}",
      "Condition": {
        "StringEquals": {
          "iam:PassedToService": "sagemaker.amazonaws.com"
        }
      }
    },
    {
      "Sid": "AllowVSCodeConnectivityInSageMaker",
      "Effect": "Allow",
      "Action": [
        "sagemaker:StartSession"
      ],
      "Resource": "*"
    },
    {
      "Sid": "AllowMLFlowInSageMaker",
      "Effect": "Allow",
      "Action": [
        "sagemaker:CallMLflowAPI",
        "sagemaker:ListExperiments",
        "sagemaker:CreateTrackingServer",
        "sagemaker:UpdateTrackingServer",
        "sagemaker:DeleteTrackingServer",
        "sagemaker:ManageTrackingServer",
        "sagemaker:ListRuns",
        "sagemaker:CreateExperiment",
        "sagemaker:ListModelPackages",
        "sagemaker:CreateModelPackage",
        "s3:GetObject",
        "s3:PutObject"
      ],
      "Resource": "*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "aoss:APIAccessAll"
      ],
      "Resource": "${aoss_arn}"
    },
    {
        "Sid": "ReadPermissionOnPlatformParameterStore",
        "Effect": "Allow",
        "Action": [
            "ssm:GetParametersByPath",
            "ssm:GetParameters",
            "ssm:GetParameter"
        ],
        "Resource": "${param_store_resource_arn_read}"
    },
    {
      "Effect": "Deny",
      "Action": [
        "sagemaker:CreateModel",
        "sagemaker:CreateEndpointConfig",
        "sagemaker:CreateEndpoint",
        "sagemaker:UpdateEndpoint",
        "sagemaker:DeleteModel",
        "sagemaker:DeleteEndpointConfig",
        "sagemaker:DeleteEndpoint"
      ],
      "Resource": "*"
    }
  ]
}
</content>

<content full_path="base/inputs/sandbox/982534393096_46de60f5-2b31-4fb7-9cbf-b728d5b104e3.tfvars">
aws_region     = "us-east-1"
aws_account_id = "982534393096"
project_id     = "46de60f5-2b31-4fb7-9cbf-b728d5b104e3"


vpc = {
  cidr_block             = "10.93.128.0/22"
  number_azs             = 2
  sagemaker_subnet_cidrs = ["10.93.128.0/25", "10.93.128.128/25"]
  endpoint_subnet_cidrs  = ["10.93.129.0/25", "10.93.129.128/25"]
}

tags = {
  "project_id"   = "46de60f5-2b31-4fb7-9cbf-b728d5b104e3",
  "aide-id"      = "AIDE_0074310"
  "hcp_rg"       = "migration-aide-0074310-4416a57",
  "environment"  = "dev",
  "service-tier" = "p2"
}

endpoint_names = ["ecr.api", "ecr.dkr", "logs", "ssm", "ssmmessages", "ec2messages", "sagemaker.api", "secretsmanager", "sagemaker.runtime",
  "sagemaker.featurestore-runtime", "servicecatalog", "forecast", "forecastquery", "rekognition", "textract", "comprehend", "sts", "redshift-data",
"athena", "glue", "codewhisperer", "bedrock", "bedrock-agent", "bedrock-agent-runtime"]

</content>

<content full_path="base/s3_bucket/data.tf">
data "aws_caller_identity" "current" {}

data "aws_region" "current" {}
</content>

<content full_path="base/s3_bucket/outputs.tf">
output "workspace_bucket_id" {
  value = aws_s3_bucket.workspace_bucket.id
}

output "workspace_bucket_arn" {
  value = aws_s3_bucket.workspace_bucket.arn
}

output "byod_bucket_id" {
  value = aws_s3_bucket.byod_bucket.id
}

output "byod_bucket_arn" {
  value = aws_s3_bucket.byod_bucket.arn
}

output "service_bucket_id" {
  value = aws_s3_bucket.service_bucket.id
}

output "service_bucket_arn" {
  value = aws_s3_bucket.service_bucket.arn
}
</content>

<content full_path="base/s3_bucket/byod_bucket.tf">
resource "aws_s3_bucket" "byod_bucket" {
  bucket = "${var.bucket_prefix}-byod-bucket"
  tags   = var.tags
}

resource "aws_s3_bucket_server_side_encryption_configuration" "byod_bucket" {
  bucket = aws_s3_bucket.byod_bucket.bucket
  rule {
    apply_server_side_encryption_by_default {
      kms_master_key_id = var.kms_arn
      sse_algorithm     = "aws:kms"
    }
  }
}

resource "aws_s3_bucket_lifecycle_configuration" "byod_bucket_life_cycle_config" {
  bucket = aws_s3_bucket.byod_bucket.id

  rule {
    id = "life-cycle-configuration-rule"
    abort_incomplete_multipart_upload {
      days_after_initiation = 1
    }
    status = "Enabled"
    filter {}  # Applies to all objects in the bucket
  }
}

resource "aws_s3_bucket_logging" "byod_bucket_access_log" {
  bucket = aws_s3_bucket.byod_bucket.id

  target_bucket = aws_s3_bucket.byod_bucket.id
  target_prefix = "log/"
}

resource "aws_s3_bucket_versioning" "byod_bucket_versioning" {
  bucket = aws_s3_bucket.byod_bucket.id
  versioning_configuration {
    status = "Enabled"
  }
}

resource "aws_s3_bucket_policy" "byod_bucket_policy" {
  bucket = aws_s3_bucket.byod_bucket.id

  policy = jsonencode({
    Version = "2012-10-17",
    Statement = [
      {
        Effect = "Allow",
        Principal = {
          AWS = [
            var.sagemaker_role_arn
          ]
        },
        Action = [
          "s3:GetObject",
          "s3:ListBucket",
          "s3:GetBucketAcl"
        ],
        Resource = [
          aws_s3_bucket.byod_bucket.arn,
          "${aws_s3_bucket.byod_bucket.arn}/*"
        ]
      },
      {
        Effect = "Deny",
        Principal = "*",
        Action = [
          "s3:PutObject",
          "s3:PutObjectAcl"
        ],
        Resource = [
          aws_s3_bucket.byod_bucket.arn,
          "${aws_s3_bucket.byod_bucket.arn}/*"
        ],
        Condition = {
          NotIpAddress = {
            "aws:SourceIp" = var.tower_ips
          }
        }
      }
    ]
  })
}

</content>

<content full_path="base/s3_bucket/service_bucket.tf">
resource "aws_s3_bucket" "service_bucket" {
  bucket = "${var.bucket_prefix}-service-bucket"
  tags   = var.tags
}

resource "aws_s3_bucket_server_side_encryption_configuration" "service_bucket" {
  bucket = aws_s3_bucket.service_bucket.bucket
  rule {
    apply_server_side_encryption_by_default {
      kms_master_key_id = var.kms_arn
      sse_algorithm     = "aws:kms"
    }
  }
}

resource "aws_s3_bucket_lifecycle_configuration" "service_bucket_life_cycle_config" {
  bucket = aws_s3_bucket.service_bucket.id

  rule {
    id = "life-cycle-configuration-rule"
    abort_incomplete_multipart_upload {
      days_after_initiation = 1
    }
    status = "Enabled"
    filter {}  # Applies to all objects in the bucket
  }
}

resource "aws_s3_bucket_logging" "service_bucket_access_log" {
  bucket = aws_s3_bucket.service_bucket.id

  target_bucket = aws_s3_bucket.service_bucket.id
  target_prefix = "log/"
}

resource "aws_s3_bucket_versioning" "service_bucket_versioning" {
  bucket = aws_s3_bucket.service_bucket.id
  versioning_configuration {
    status = "Enabled"
  }
}
</content>

<content full_path="base/s3_bucket/variables.tf">
variable "tower_ips" {
    description = "Optum Tower IPs"
    type        = list(string)
}

variable "bucket_prefix" {
  description = "Name of Project"
  type        = string
}

variable "tags" {
  type        = map(string)
  description = "Tags to apply to resources."
}

variable "kms_arn" {
  description = "kms key to encrypt EFS"
  type        = string
}

variable "sagemaker_role_arn" {
  description = "arn of sagemaker domain"
  type        = string
}
</content>

<content full_path="base/s3_bucket/workspace_bucket.tf">
resource "aws_s3_bucket" "workspace_bucket" {
  bucket = "${var.bucket_prefix}-workspace-bucket"
  tags   = var.tags
}

resource "aws_s3_bucket_server_side_encryption_configuration" "workspace_bucket" {
  bucket = aws_s3_bucket.workspace_bucket.bucket
  rule {
    apply_server_side_encryption_by_default {
      kms_master_key_id = var.kms_arn
      sse_algorithm     = "aws:kms"
    }
  }
}

resource "aws_s3_bucket_lifecycle_configuration" "workspace_bucket_life_cycle_config" {
  bucket = aws_s3_bucket.workspace_bucket.id

  rule {
    id = "life-cycle-configuration-rule"
    abort_incomplete_multipart_upload {
      days_after_initiation = 1
    }
    status = "Enabled"
    filter {}  # Applies to all objects in the bucket
  }
}

resource "aws_s3_bucket_logging" "workspace_bucket_access_log" {
  bucket = aws_s3_bucket.workspace_bucket.id

  target_bucket = aws_s3_bucket.workspace_bucket.id
  target_prefix = "log/"
}

resource "aws_s3_bucket_versioning" "workspace_bucket_versioning" {
  bucket = aws_s3_bucket.workspace_bucket.id
  versioning_configuration {
    status = "Enabled"
  }
}

resource "aws_s3_bucket_policy" "workspace_bucket_policy" {
  bucket = aws_s3_bucket.workspace_bucket.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          AWS = [
            var.sagemaker_role_arn
          ]
        }
        Action = [
          "s3:GetObject",
          "s3:PutObject",
          "s3:ListBucket",
          "s3:GetBucketAcl",
          "s3:PutObjectAcl"
        ]
        Resource = [
          aws_s3_bucket.workspace_bucket.arn,
          "${aws_s3_bucket.workspace_bucket.arn}/*"
        ]
      }
    ]
  })
}
</content>

</repo-to-text>
